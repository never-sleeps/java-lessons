#### Синхронизированные коллекции
```java
public static <T> Collection<T> synchronizedCollection(Collection<T> c); public static <T> Set<T> synchronizedSet(Set<T> s);
public static <T> List<T> synchronizedList(List<T> list);
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m);
public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s); public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m);
```


#### Concurrent коллекции
- `CopyOnWriteArrayList` - Потокобезопасный аналог `ArrayList`, в котором все операции изменения (`add`, `set`, и т.д.) реализованы через создание новой копии базового массива
- `CopyOnWriteArraySet` - Обертка/wrapper для `CopyOnWriteArrayList` (использует `addIfAbsent`)
- `ConcurrentHashMap` - Аналог `HashMap`, где данные представлены в виде сегментов, разбитых по hash-ам ключей. При этом доступ к данным блокируется на уровне сегмента, а не всего объекта. При этом блокируется только запись. Итераторы представляют данные на определенный срез времени и не кидают `ConcurrentModificationException`
- `ConcurrentSkipListMap` - Аналог коллекции `TreeMap` с сортировкой данных по ключу и с поддержкой многопоточности
- `ConcurrentSkipListSet` - Реализация интерфейса `Set`, выполненная на основе класса `ConcurrentSkipListMap`

#### Очереди

- `ConcurrentLinkedQueue` - Неограниченная, неблокирующая очередь, на основе связанного списка (ноды). Для работы использует CAS
- `ArrayBlockingQueue` - Блокирующая очередь, на основе массива и `ReentrantLock`. Помимо размера очереди, доступна возможность управлять “честностью” блокировок (`fair`). Если `fair` = `false` (по умолчанию), то очередность работы потоков не гарантируется
- `LinkedBlockingQueue` - Опционально ограниченная блокирующая очередь, на основе связанного списка и двух `ReentrantLock` (`takeLock`, `putLock`)
- `PriorityBlockingQueue` - Обертка над `PriorityQueue`. При вставке элемента в очередь, его порядок определяется в соответствии с логикой `Comparator`'а или имплементации `Comparable` интерфейса у элементов. Первым из очереди выходит самый наименьший элемент

Разделение по поведению в случае, если невозможно моментально выполнить действие

|          | Кидают исключение   | Возвращают спец.значение (null/false)   | Блокируют поток   | Блокируют поток на заданное время |
|----------|---------------------|-----------------------------------------|-------------------|-----------------------------------|
| Вставка  | `add(e)`            | `offer(e)`                              | `put(e)`          | `offer(e, time, unit)`            |
| Удаление | `remove()`          | `poll()`                                | `take()`          | `poll(time, unit)`                |
| Чтение   | `element()`         | `peek()`                                |                   |                                   |



| Метод                  | Описание                                                                                                                                                                      |
|------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `add(e)`               | Вставляет элемент в очередь, если это можно сделать, не нарушая ограничения емкости. Возвращает `true` в случае успеха. В противном случае выбрасывает `IllegalStateException`|
| `put(e)`               | Помещает элемент в очередь, если очередь заполнена - блокирует выполнение до освобождения места в очереди и успешного помещения в нее нового элемента                         |
| `offer(e)`             | Добавляет элемент в очередь, если это можно сделать, не нарушая ограничения емкости. Возвращает `true` в случае успеха. В противном случае возвращает `false`                 |
| `offer(e, time, unit)` | Ждет указанное время освобождения места в очереди, а потом ведет себя аналогично `offer(e)`                                                                                   |
| `remove()`             | Удаление объекта из очереди, если он в ней присутствует. В противном случае выбрасывает `NoSuchElementException`                                                              |
| `poll()`               | Извлекает и удаляет элемент из головы очереди. Если очередь пустая, возвращает `null`                                                                                         |
| `take()`               | Извлекает и удаляет элемент из головы очереди. Если очередь пустая блокирует выполнение до появления элемента                                                                 |
| `poll(time, unit)`     | Ждет указанное время появления элемента в очереди, а потом ведет себя аналогично `poll() `                                                                                    |
| `element()`            | Извлекает, но не удаляет элемент из головы очереди. Если очередь пуста выбрасывает `NoSuchElementException`                                                                   |
| `peek()`               | Извлекает, но не удаляет элемент из головы очереди. Если очередь пуста возвращает `null`                                                                                      |


