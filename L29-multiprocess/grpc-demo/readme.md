#### gRPC
gRPC —  разработан компанией Google для вызова удаленных процедур (RPC), работает поверх HTTP/2.  
gRPC отлично подходит для создания распределенных систем (микросервисов) и API. Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов.  
Высокая производительность достигается за счет использования протокола HTTP/2 и Protocol Buffers. 

Преимущества:
- Вместо `json` для передачи данных используется бинарный формат Protobuf: меньше размер сообщений, быстрее передача данных (в 7-10 раз)
- HTTP 2 вместо HTTP 1.1: легко стримить потоки данных и не только.
- Генерация кода для самых популярных языков программирования (более 10).

#### REST. Недостатки:
- Для каждого языка программирования необходимо писать свой код для API. Можно генерировать код с помощью сторонних инструментов (например, swagger), но нет стандартного способа это делать.  
- `json`, который используется в rest api для передачи данных - не бинарный формат данных, а текстовый (данные никак не сжимаются при пересылке). Он удобен в плане читаемости человеком, но неэффективен - больше размер сообщения, медленнее пересылка.  
- Обычно используется протокол HTTP 1.1, а не HTTP 2. Непросто реализовать стриминг потоковых данных.

#### Protobuf
Protobuf - формат сериализации используемый по умолчанию для передачи данных между клиентом и сервером.  
Используя строгую типизацию полей и бинарный формат для передачи структурированных данных потребляет меньше ресурсов. 
Время выполнения процесса сериализации/десериализации значительно меньше, как и размер сообщений в отличие от JSON/XML.
Для написания protobuf файлов используют язык описания интерфейсов (IDL).  
Например, чтобы описать структуру данных сообщения, нужно добавить message, имя структуры, а внутри тип, название и номер поля. Номера полей очень важны для обратной совместимости, поэтому не стоит менять их последовательность при добавлении или удалении полей. Старые номера можно резервировать.

| json                                                                         | protobuf                                       |
|------------------------------------------------------------------------------|------------------------------------------------|
| + читаемый и простой                                                         | + бинарный и эффективный (используется сжатие) |
| + нет необходимости кодировать и декодировать                                | + имеет строгую типизацию                      |
|                                                                              |                                                |
| - не сжимается при передаче (передаётся как текст), большой размер сообщения | - нечитаемый                                   |
| - избыточный (ключи повторяются)                                             | - необходимо кодировать и декодировать данные  |
| - нет строгой типизации                                                      |                                                |

#### HTTP 2 (новый протокол передачи данных по сети) - 2015
- бинарный формат передачи сообщений (в отличие от текстового HTTP 1.1)
- более продвинутое сжатие HTTP-сообщений: меньший размер, выше скорость
- потоки данных
- мультиплексирование, приоритизация потоков и др.

#### Типы RPC
- Unary RPC (унарный). Синхронный запрос клиента, который блокируется пока не будет получен ответ от сервера.  
- Server streaming RPC (серверный стрим), при подключении клиента сервер открывает стрим и начинает отправлять сообщения.  
- Client streaming RPC (клиентский стрим). То же самое, что и серверный, только клиент начинает стримить сообщения на сервер.  
- Bidirectional streaming (двунаправленный стрим). Клиент инициализирует соединение, создаются два стрима. Сервер может отправить изначальные данные при подключении или отвечать на каждый запрос клиента по типу “пинг-понга”.

#### gRPC – как пользоваться:
- В “.proto”-файле описываем типы данных, формат сообщений, rpc-операции
- Там же описываем сервис(ы), что будут эти сообщения получать и отправлять
- Компилируем “.proto” файл в java код. Это можно сделать внешним компилятором или через плагин для системы сборки.
Сгенерированный для сервиса класс позволяет с одной стороны создать клиентскую заглушку, а с другой содержит внутри себя абстрактный класс, который нужно реализовать на стороне сервера (некоторые методы)
