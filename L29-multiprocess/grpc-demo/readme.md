#### gRPC
gRPC —  разработан компанией Google для вызова удаленных процедур (RPC), работает поверх HTTP/2.  
gRPC отлично подходит для создания распределенных систем (микросервисов) и API. Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов.  
Высокая производительность достигается за счет использования протокола HTTP/2 и Protocol Buffers. 

Преимущества:
- Вместо `json` для передачи данных используется бинарный формат Protobuf: меньше размер сообщений, быстрее передача данных (в 7-10 раз)
- HTTP 2 вместо HTTP 1.1: легко стримить потоки данных и не только.
- Генерация кода для самых популярных языков программирования (более 10).

#### REST. Недостатки:
- Для каждого языка программирования необходимо писать свой код для API. Можно генерировать код с помощью сторонних инструментов (например, swagger), но нет стандартного способа это делать.  
- `json`, который используется в rest api для передачи данных - не бинарный формат данных, а текстовый (данные никак не сжимаются при пересылке). Он удобен в плане читаемости человеком, но неэффективен - больше размер сообщения, медленнее пересылка.  
- Обычно используется протокол HTTP 1.1, а не HTTP 2. Непросто реализовать стриминг потоковых данных.

#### Protobuf
Protobuf - формат сериализации используемый по умолчанию для передачи данных между клиентом и сервером.  
Используя строгую типизацию полей и бинарный формат для передачи структурированных данных потребляет меньше ресурсов. 
Время выполнения процесса сериализации/десериализации значительно меньше, как и размер сообщений в отличие от JSON/XML.
Для написания protobuf файлов используют язык описания интерфейсов (IDL).  
Например, чтобы описать структуру данных сообщения, нужно добавить message, имя структуры, а внутри тип, название и номер поля. Номера полей очень важны для обратной совместимости, поэтому не стоит менять их последовательность при добавлении или удалении полей. Старые номера можно резервировать.

protobuf:
- +бинарный и эффективный (используется сжатие)
- +имеет строгую типизацию
- -нечитаемый
- -необходимо кодировать и декодировать данные

json
- +читаемый и простой 
- +нет необходимости кодировать и декодировать
- -не сжимается при передаче (передаётся как текст), большой размер сообщения
- -избыточный (ключи повторяются)
- -нет строгой типизации


#### HTTP 2 (новый протокол передачи данных по сети) - 2015
- бинарный формат передачи сообщений (в отличие от текстового HTTP 1.1)
- более продвинутое сжатие HTTP-сообщений: меньший размер, выше скорость
- потоки данных
- мультиплексирование, приоритизация потоков и др.

|                      | HTTP/2   | HTTP/1.1  |
|----------------------|----------|-----------|
| протокол             | бинарный | текстовый |
| сжатие заголовков    | +        | -         |
| мультиплексирование  | +        | -         |
| запросы в соединении | много    | 1         |
| server push          | да       | нет       |

#### Типы RPC
- Unary RPC (унарный). Синхронный запрос клиента, который блокируется пока не будет получен ответ от сервера.  
- Server streaming RPC (серверный стрим), при подключении клиента сервер открывает стрим и начинает отправлять сообщения.  
- Client streaming RPC (клиентский стрим). То же самое, что и серверный, только клиент начинает стримить сообщения на сервер.  
- Bidirectional streaming (двунаправленный стрим). Клиент инициализирует соединение, создаются два стрима. Сервер может отправить изначальные данные при подключении или отвечать на каждый запрос клиента по типу “пинг-понга”.

#### gRPC – как пользоваться:
- В “.proto”-файле описываем типы данных, формат сообщений, rpc-операции
- Там же описываем сервис(ы), что будут эти сообщения получать и отправлять
- Компилируем “.proto” файл в java код. Это можно сделать внешним компилятором или через плагин для системы сборки.
Сгенерированный для сервиса класс позволяет с одной стороны создать клиентскую заглушку, а с другой содержит внутри себя абстрактный класс, который нужно реализовать на стороне сервера (некоторые методы)
